package org.mdf.mockdata;

import java.io.StringReader;
import java.sql.CallableStatement;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.exolab.castor.xml.Unmarshaller;
import org.exolab.castor.xml.XMLContext;
import org.mdf.mockdata.generated.MockData;
import org.mdf.mockdata.remote.HttpClient;
import org.mdf.mockdata.remote.RemoteMockPreparedStatement;

import com.mockrunner.mock.jdbc.MockDatabaseMetaData;
import com.mockrunner.mock.jdbc.MockResultSet;

public class MockConnection extends com.mockrunner.mock.jdbc.MockConnection {

    protected MockDataManager _mockDataManager;
    private MockDriver _driver;
    private String _remoteURL;
    private HttpClient _httpClient;
    private Map<String, Integer> _customFunctionMap = new HashMap<String, Integer>();

    public MockConnection(MockDataManager mockDataManager) {
        this(mockDataManager, null, null);
    }
    
    public MockConnection(MockDataManager mockDataManager, String remoteURL, HttpClient httpClient) {
        _mockDataManager = mockDataManager;
        _remoteURL = remoteURL;
        _httpClient = httpClient;
    }
    
    public MockConnection(MockDriver parent) {
        _driver = parent;
    }

    public PreparedStatement prepareStatement(String sql) throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement(sql);
        return preparedStatement;
    }


    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
            int resultSetHoldability) throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement(sql);
        return preparedStatement;
    }

    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
            throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement(sql);
        return preparedStatement;
    }

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement(sql);
        return preparedStatement;
    }

    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement(sql);
        return preparedStatement;
    }

    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement(sql);
        return preparedStatement;
    }

    @Override
    public Statement createStatement() throws SQLException {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = createMockPreparedStatement("");
        return preparedStatement;
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
            throws SQLException {
        return createStatement();
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return createStatement();
    }
    
    public CallableStatement prepareCall(String sql) throws SQLException {
        Logger.getLogger(getClass()).info("creating callable statement");
        MockCallableStatement statement = new MockCallableStatement(this, sql, _mockDataManager);
        getCallableStatementResultSetHandler().addCallableStatement(statement);
        return statement;
    }
    
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return prepareCall(sql);
    }
    
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return prepareCall(sql);
    }

    public DatabaseMetaData getMetaData() throws SQLException {
        MockDatabaseMetaData metaData = new MockDatabaseMetaData() {
            public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types)
                    throws SQLException {
                MockResultSet resultSet = new MockResultSet("getTables");
                resultSet.addColumn("TABLE_CAT");
                resultSet.addColumn("TABLE_SCHEM");
                resultSet.addColumn("TABLE_NAME");
                resultSet.addRow(new String[] { catalog, schemaPattern, tableNamePattern, null });
                return resultSet;
            }
            
            public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException
            {
                return new MockResultSet("getColumns");
            }

            @Override
            public ResultSet getImportedKeys(String catalog, String schema, String table) throws SQLException {
                return new MockResultSet("getImportedKeys");
            }

            @Override
            public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique,
                    boolean approximate) throws SQLException {
                return new MockResultSet("getIndexInfo");
            }
        };
        metaData.setDatabaseProductName("Oracle");
        metaData.setDatabaseMajorVersion(9);
        metaData.setURL(_remoteURL);
        return metaData;
    }

    public MockDataManager getMockDataManager() {
        return _mockDataManager;
    }

    public void close() throws SQLException {
        super.close();
    }
    
    @SuppressWarnings("deprecation")
    public String nativeSQL(String sql) throws SQLException {
        if (sql.startsWith("setMockData:")) {
            String mockDataString = sql.substring("setMockData:".length());
            XMLContext context = new XMLContext();
            Unmarshaller unmarshaller = context.createUnmarshaller();
            unmarshaller.setClass(MockData.class);
            try {
                MockData mockData = (MockData) unmarshaller.unmarshal(new StringReader(mockDataString));
                MockDataManager mockDataManager = new MockDataManager(mockData);
                if (mockDataManager.getCategoryMatcher() == null) {
                    mockDataManager.setCategoryMatcher(new SqlSnippetMatcher());
                }
                if (_driver != null) {
                    _driver.resetMockDataManager();
                    _mockDataManager = mockDataManager;
                    _driver.setMockDataManager(mockDataManager);
                } else {
                    _mockDataManager = mockDataManager;
                }
            } catch (Exception e) {
                throw new SQLException("Unable to parse xml");
            }
            return null;
        } else if (sql.startsWith("validateCapturedData:")) {
            String validateString = sql.substring("validateCapturedData:".length());
            String[] validateValues = validateString.split("\\|");
            if (validateValues.length < 3) {
                return null;
            }
            String table = validateValues[0];
            Map<String, String> values = new HashMap<String, String>();
            for (int i = 1; i < validateValues.length; i += 2) {
                String key = validateValues[i];
                String value = null;
                if (validateValues.length > i + 1) {
                    value = validateValues[i+1];
                }
                values.put(key, value);
            }
            try {
                if (_mockDataManager.validateCapturedData(table, values)) {
                    return "true";
                } else {
                    return "false";
                }
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        } else if (sql.startsWith("addCustomFunction:")) {
            String customFunctionString = sql.substring("addCustomFunction:".length());
            String[] customFunctions = customFunctionString.split("\\|");
            if (customFunctions.length == 0 || customFunctions.length % 2 != 0) {
                return null;
            }
            Map<String, Integer> customFunctionMap = new HashMap<String, Integer>();
            for (int i = 0; i < customFunctions.length; i++) {
                customFunctionMap.put(customFunctions[i], Integer.parseInt(customFunctions[++i]));
            }
            if (_driver != null) {
                _driver.addCustomFunctions(customFunctionMap);
            } else {
                _customFunctionMap.putAll(customFunctionMap);
            }
            return null;
        } else {
            return super.nativeSQL(sql);
        }
    }
    
    void setCustomFunctionMap(Map<String, Integer> customFunctionMap) {
        _customFunctionMap = customFunctionMap;
    }

    private com.mockrunner.mock.jdbc.MockPreparedStatement createMockPreparedStatement(String sql) {
        com.mockrunner.mock.jdbc.MockPreparedStatement preparedStatement = null;
        if (_remoteURL != null) {
            preparedStatement = new RemoteMockPreparedStatement(this, sql, _httpClient);
        } else {
            preparedStatement = new MockPreparedStatement(this, sql, _mockDataManager);
            ((MockPreparedStatement)preparedStatement).setCustomFunctionMap(_customFunctionMap);
        }
        getPreparedStatementResultSetHandler().addPreparedStatement(preparedStatement);
        return preparedStatement;
    }

}
